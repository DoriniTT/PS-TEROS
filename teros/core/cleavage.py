"""Cleavage energy calculations for oxide surfaces.

This module implements cleavage energy calculations for complementary slab pairs
generated by pymatgen's SlabGenerator. The cleavage energy quantifies the energy
required to split a crystal into two complementary surfaces.

Reference:
    Yang et al., cleavage energy formula for symmetric surfaces:
    Ec(i,j) = 1/(2A) * (E_i^slab + E_j^slab - n*E_bulk)
"""

from __future__ import annotations

import typing as t
from collections import Counter
from functools import reduce
from math import gcd

import numpy as np
from aiida import orm
from aiida_workgraph import dynamic, namespace, task


@task.calcfunction
def calculate_cleavage_energy(
    bulk_structure: orm.StructureData,
    bulk_energy: orm.Float,
    slab_i_structure: orm.StructureData,
    slab_i_energy: orm.Float,
    slab_j_structure: orm.StructureData,
    slab_j_energy: orm.Float,
    term_i: orm.Int,
    term_j: orm.Int,
) -> orm.Dict:
    """
    Calculate cleavage energy for a pair of complementary slabs.
    
    The cleavage energy is calculated using:
        Ec(i,j) = 1/(2A) * (E_i^slab + E_j^slab - n*E_bulk)
    
    where:
        - E_i^slab, E_j^slab: total energies of complementary slabs
        - A: surface area of the slab
        - n: number of formula units in the combined slabs
        - Factor 1/(2A) accounts for two surfaces created by cleavage
    
    Args:
        bulk_structure: Bulk structure
        bulk_energy: Total energy of bulk structure (eV)
        slab_i_structure: First slab structure
        slab_i_energy: Total energy of first slab (eV)
        slab_j_structure: Second (complementary) slab structure
        slab_j_energy: Total energy of second slab (eV)
        term_i: Termination index of first slab
        term_j: Termination index of second slab
        
    Returns:
        Dictionary containing cleavage energy and related data
    """
    # Get bulk composition
    bulk_ase = bulk_structure.get_ase()
    bulk_counts = Counter(bulk_ase.get_chemical_symbols())
    
    if 'O' not in bulk_counts:
        raise ValueError('Bulk structure contains no oxygen; expected an oxide.')
    
    # Get metal elements (all non-oxygen elements)
    metal_elements = sorted(element for element in bulk_counts if element != 'O')
    
    if len(metal_elements) == 0:
        raise ValueError('No metal elements found in bulk structure.')
    
    # Get reduced stoichiometry for bulk
    stoichiometric_counts = list(bulk_counts.values())
    common_divisor = reduce(gcd, stoichiometric_counts)
    
    # Reduced stoichiometry per formula unit
    reduced_bulk_counts = {
        element: count // common_divisor 
        for element, count in bulk_counts.items()
    }
    
    # Get slab compositions
    slab_i_ase = slab_i_structure.get_ase()
    slab_i_counts = Counter(slab_i_ase.get_chemical_symbols())
    
    slab_j_ase = slab_j_structure.get_ase()
    slab_j_counts = Counter(slab_j_ase.get_chemical_symbols())
    
    # Calculate combined slab composition
    combined_counts = {
        element: slab_i_counts.get(element, 0) + slab_j_counts.get(element, 0)
        for element in bulk_counts.keys()
    }
    
    # Calculate number of formula units in combined slabs
    # Use the first element for the calculation (should give same result for all)
    ref_element = list(reduced_bulk_counts.keys())[0]
    n_formula_units = combined_counts[ref_element] / reduced_bulk_counts[ref_element]
    
    # Verify stoichiometry is consistent
    for element in reduced_bulk_counts.keys():
        expected_atoms = n_formula_units * reduced_bulk_counts[element]
        actual_atoms = combined_counts[element]
        if not np.isclose(expected_atoms, actual_atoms, rtol=1e-3):
            raise ValueError(
                f'Stoichiometry mismatch for {element}: '
                f'expected {expected_atoms:.2f} atoms, found {actual_atoms}'
            )
    
    # Calculate surface area from slab structure
    # For orthogonal slabs: A = ||a|| Ã— ||b||
    slab_i_cell = slab_i_ase.get_cell()
    a_vector = slab_i_cell[0]
    b_vector = slab_i_cell[1]
    
    # Surface area (magnitude of cross product for general case)
    cross_product = np.cross(a_vector, b_vector)
    area = float(np.linalg.norm(cross_product))
    
    # Calculate cleavage energy
    # Ec(i,j) = 1/(2A) * (E_i + E_j - n*E_bulk)
    numerator = (
        slab_i_energy.value 
        + slab_j_energy.value 
        - n_formula_units * bulk_energy.value
    )
    cleavage_energy = numerator / (2.0 * area)
    
    # Convert from eV/Angstrom^2 to J/m^2 (common units for surface energy)
    # 1 eV/Angstrom^2 = 16.0217663 J/m^2
    cleavage_energy_J_m2 = cleavage_energy * 16.0217663
    
    return orm.Dict(
        dict={
            'cleavage_energy_eV_A2': float(cleavage_energy),
            'cleavage_energy_J_m2': float(cleavage_energy_J_m2),
            'term_i': int(term_i.value),
            'term_j': int(term_j.value),
            'pair_label': f'term_{term_i.value}_term_{term_j.value}',
            'n_formula_units': float(n_formula_units),
            'area_A2': float(area),
            'E_slab_i_eV': float(slab_i_energy.value),
            'E_slab_j_eV': float(slab_j_energy.value),
            'E_bulk_eV': float(bulk_energy.value),
            'bulk_stoichiometry': reduced_bulk_counts,
            'slab_i_composition': dict(slab_i_counts),
            'slab_j_composition': dict(slab_j_counts),
            'combined_composition': combined_counts,
        }
    )


@task.graph
def compute_cleavage_energies_scatter(
    slabs: t.Annotated[dict[str, orm.StructureData], dynamic(orm.StructureData)],
    energies: t.Annotated[dict[str, orm.Float], dynamic(orm.Float)],
    bulk_structure: orm.StructureData,
    bulk_energy: orm.Float,
) -> t.Annotated[dict, namespace(cleavage_energies=dynamic(orm.Dict))]:
    """
    Compute cleavage energies for all complementary slab pairs.
    
    Pymatgen's SlabGenerator produces slabs in a consistent complementary ordering:
    - For even number of terminations (e.g., 4): pairs are (0,3), (1,2)
    - For odd number of terminations (e.g., 5): pairs are (0,4), (1,3), (2,2)
    
    This function automatically determines the complementary pairs and calculates
    cleavage energy for each pair in parallel.
    
    Args:
        slabs: Dynamic namespace of slab structures (keyed by 'term_0', 'term_1', ...)
        energies: Dynamic namespace of slab energies (same keys as slabs)
        bulk_structure: Bulk structure
        bulk_energy: Bulk total energy
        
    Returns:
        Dictionary with 'cleavage_energies' namespace containing
        cleavage energy data for each complementary pair
    """
    # Extract termination indices from keys (e.g., 'term_0' -> 0)
    term_indices = sorted([int(key.split('_')[1]) for key in slabs.keys()])
    n_terms = len(term_indices)
    
    if n_terms == 0:
        raise ValueError('No slab terminations provided.')
    
    # Generate complementary pairs according to pymatgen convention
    # For n terminations indexed 0 to n-1:
    # Pairs are: (0, n-1), (1, n-2), ..., up to the middle
    cleavage_results = {}
    
    for i in range((n_terms + 1) // 2):  # Ceiling division
        j = n_terms - 1 - i  # Complementary index
        
        # Get structures and energies for this pair
        term_i_key = f'term_{i}'
        term_j_key = f'term_{j}'
        
        slab_i = slabs[term_i_key]
        slab_j = slabs[term_j_key]
        energy_i = energies[term_i_key]
        energy_j = energies[term_j_key]
        
        # Calculate cleavage energy for this pair
        cleavage_data = calculate_cleavage_energy(
            bulk_structure=bulk_structure,
            bulk_energy=bulk_energy,
            slab_i_structure=slab_i,
            slab_i_energy=energy_i,
            slab_j_structure=slab_j,
            slab_j_energy=energy_j,
            term_i=orm.Int(i),
            term_j=orm.Int(j),
        ).result
        
        # Store with key indicating the pair
        pair_key = f'pair_{i}_{j}'
        cleavage_results[pair_key] = cleavage_data
    
    return {'cleavage_energies': cleavage_results}
