Project Structure

    teros/: The main source code directory.

        core/: Contains the primary AiiDA-WorkGraph workflow definitions. The main graph builder function, create_teros_workgraph, resides here.

        functions/: Holds the core scientific and utility functions that are decorated as AiiDA tasks.

            thermodynamics/: Specifically for thermodynamics calculations like formation enthalpy and surface energy.

        utils/: For helper utilities that do not directly form the main workflow but are used for tasks like plotting or output formatting.

        tests/: Contains test scripts for the various components of Teros.

    teros.egg-info/: Automatically generated by setuptools and contains package metadata.

    setup.py: The script for package installation and dependency management.

AiiDA-WorkGraph Usage

    Graph Builder: The main workflow should be constructed within a function decorated with @task.graph_builder. The create_teros_workgraph function is the central entry point for creating and running calculations.

    Tasks: Individual computational steps should be defined as functions and decorated with @task.calcfunction() or a similar aiida-workgraph decorator. This allows them to be used as nodes in the workgraph.

    Data Flow: Data should be passed between tasks using their outputs. For example, the output of a relaxation task (bulk_task.outputs.output_structure) is used as an input for the slab generation task.

    Active Map Zone: For operations that need to be performed on a collection of items (like relaxing multiple slabs), use the active_map_zone. This is demonstrated in the slab_relaxation part of the workgraph.py.

Function and Task Design

    Modularity: Keep functions focused on a single, well-defined purpose. For example, calculate_formation_enthalpy and get_slabs are separate functions for separate tasks.

    AiiDA Data Types: Functions that are part of the AiiDA workflow should accept and return AiiDA data types (e.g., StructureData, Dict, List, Float). This is crucial for provenance and data integrity.

    Code-Specific Logic: Any logic that is specific to a particular DFT code (like "VASP" or "QUANTUM_ESPRESSO") should be handled using conditional statements, as seen in how output parameters are parsed in workgraph.py.

Coding Style and Conventions

    Docstrings: All modules, functions, and classes should have clear and comprehensive docstrings explaining their purpose, parameters, and return values. The existing code uses a consistent style for this.

    Naming: Use descriptive names for variables and functions (e.g., bulk_relaxation, reference_builders).

    Clarity: The code is well-commented and broken down into logical blocks, which should be maintained.

Dependency Management

    setup.py and requires.txt: All project dependencies should be listed in the install_requires section of setup.py and in requires.txt. This ensures that anyone installing the package gets all the necessary libraries.

Testing

    Test Scripts: Create dedicated test scripts for different functionalities, such as test_slab_generation.py. This helps ensure that individual components of the workflow are working correctly.

    Example Usage: Include example usage sections or scripts to demonstrate how to use the main functions and workflows. The example_usage function in output_formatter.py is a good example.