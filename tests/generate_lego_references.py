#!/usr/bin/env python
"""Generate reference calculations for tier3 lego tests.

Usage:
    # Generate all reference calculations on localwork:
    python tests/generate_lego_references.py --code VASP-6.5.1@localwork

    # Generate only VASP brick references:
    python tests/generate_lego_references.py --code VASP-6.5.1@localwork --brick vasp

    # Check status of submitted references:
    python tests/generate_lego_references.py --status

    # Wait for all references to finish, then save PKs:
    python tests/generate_lego_references.py --wait

This script submits lightweight VASP calculations using the lego quick functions,
waits for them to complete, and writes the WorkGraph PKs to
tests/fixtures/lego_reference_pks.json for use by tier3 tests.
"""

import argparse
import json
import os
import sys
import time

FIXTURES_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'fixtures')
STRUCTURES_DIR = os.path.join(FIXTURES_DIR, 'structures')
PK_FILE = os.path.join(FIXTURES_DIR, 'lego_reference_pks.json')


def load_existing_pks():
    """Load existing PK file, or return empty template."""
    if os.path.exists(PK_FILE):
        with open(PK_FILE) as f:
            return json.load(f)
    return {
        '_comment': 'Auto-generated by generate_lego_references.py',
        'vasp': {},
        'dos': {},
        'batch': {},
        'aimd': {},
        'sequential': {},
    }


def save_pks(data):
    """Save PKs to JSON file."""
    with open(PK_FILE, 'w') as f:
        json.dump(data, f, indent=4)
    print(f"Saved PKs to {PK_FILE}")


def load_si_structure():
    """Load Si diamond structure from fixture file."""
    from ase.io import read as ase_read
    from aiida import orm

    filepath = os.path.join(STRUCTURES_DIR, 'si_diamond.vasp')
    atoms = ase_read(filepath, format='vasp')
    return orm.StructureData(ase=atoms)


def load_sno2_structure():
    """Load SnO2 rutile structure from fixture file."""
    from ase.io import read as ase_read
    from aiida import orm

    filepath = os.path.join(STRUCTURES_DIR, 'sno2_rutile.vasp')
    atoms = ase_read(filepath, format='vasp')
    return orm.StructureData(ase=atoms)


def get_light_options(code_label):
    """Get minimal scheduler options for the given code."""
    if 'localwork' in code_label:
        return {
            'resources': {
                'num_machines': 1,
                'num_mpiprocs_per_machine': 4,
            },
        }
    elif 'obelix' in code_label:
        return {
            'resources': {
                'num_machines': 1,
                'num_mpiprocs_per_machine': 4,
            },
            'custom_scheduler_commands': (
                '#PBS -l cput=90000:00:00\n'
                '#PBS -l nodes=1:ppn=88:skylake\n'
                '#PBS -j oe\n'
                '#PBS -N tier3_ref'
            ),
        }
    else:
        return {
            'resources': {
                'num_machines': 1,
                'num_mpiprocs_per_machine': 4,
            },
        }


# =============================================================================
# Reference generators — one per brick type
# =============================================================================

def generate_vasp_references(code_label, options):
    """Submit VASP reference calculations: Si relax + SnO2 SCF."""
    from teros.core.lego import quick_vasp

    si = load_si_structure()
    sno2 = load_sno2_structure()

    pks = {}

    # Si diamond relaxation (ISIF=3)
    pk_relax = quick_vasp(
        structure=si,
        code_label=code_label,
        incar={
            'encut': 300,
            'ediff': 1e-5,
            'ibrion': 2,
            'nsw': 20,
            'isif': 3,
            'ismear': 0,
            'sigma': 0.05,
            'prec': 'Normal',
            'lwave': False,
            'lcharg': False,
            'lreal': 'Auto',
        },
        kpoints_spacing=0.06,
        potential_family='PBE',
        potential_mapping={'Si': 'Si'},
        options=options,
        name='tier3_ref_vasp_relax_si',
    )
    pks['relax_si'] = {
        'pk': pk_relax,
        'code_label': code_label,
        'description': 'Si diamond relaxation (ISIF=3, NSW=20, ENCUT=300)',
    }
    print(f"  Submitted VASP relax Si: PK={pk_relax}")

    # SnO2 SCF (NSW=0)
    pk_scf = quick_vasp(
        structure=sno2,
        code_label=code_label,
        incar={
            'encut': 300,
            'ediff': 1e-5,
            'ibrion': -1,
            'nsw': 0,
            'ismear': 0,
            'sigma': 0.05,
            'prec': 'Normal',
            'lwave': False,
            'lcharg': False,
            'lreal': 'Auto',
        },
        kpoints_spacing=0.06,
        potential_family='PBE',
        potential_mapping={'Sn': 'Sn_d', 'O': 'O'},
        options=options,
        name='tier3_ref_vasp_scf_sno2',
    )
    pks['scf_sno2'] = {
        'pk': pk_scf,
        'code_label': code_label,
        'description': 'SnO2 rutile static SCF (NSW=0, ENCUT=300)',
    }
    print(f"  Submitted VASP SCF SnO2: PK={pk_scf}")

    return pks


def generate_dos_references(code_label, options):
    """Submit DOS reference calculation: SnO2 SCF+DOS."""
    from teros.core.lego import quick_dos

    sno2 = load_sno2_structure()

    result = quick_dos(
        structure=sno2,
        code_label=code_label,
        scf_incar={
            'encut': 300,
            'ediff': 1e-5,
            'ismear': 0,
            'sigma': 0.05,
            'prec': 'Normal',
            'lreal': 'Auto',
        },
        dos_incar={
            'encut': 300,
            'ediff': 1e-5,
            'ismear': -5,
            'nedos': 301,
            'lorbit': 11,
            'prec': 'Normal',
            'lreal': 'Auto',
        },
        kpoints_spacing=0.06,
        dos_kpoints_spacing=0.06,
        potential_family='PBE',
        potential_mapping={'Sn': 'Sn_d', 'O': 'O'},
        options=options,
        name='tier3_ref_dos_sno2',
    )
    if isinstance(result, dict) and '__workgraph_pk__' in result:
        pk = result['__workgraph_pk__']
    else:
        pk = result
    pks = {
        'dos_sno2': {
            'pk': pk,
            'code_label': code_label,
            'description': 'SnO2 rutile DOS calculation (SCF + DOS, ENCUT=300)',
        }
    }
    print(f"  Submitted DOS SnO2: PK={pk}")
    return pks


def generate_batch_references(code_label, options):
    """Submit batch reference calculation: Si with 3 ENCUT values."""
    from teros.core.lego import quick_vasp_sequential

    si = load_si_structure()

    stages = [
        {
            'name': 'encut_scan',
            'type': 'batch',
            'structure_from': 'input',
            'base_incar': {
                'ediff': 1e-5,
                'ibrion': -1,
                'nsw': 0,
                'ismear': 0,
                'sigma': 0.05,
                'prec': 'Normal',
                'lwave': False,
                'lcharg': False,
                'lreal': 'Auto',
            },
            'calculations': {
                'encut_200': {'incar': {'encut': 200}},
                'encut_250': {'incar': {'encut': 250}},
                'encut_300': {'incar': {'encut': 300}},
            },
        },
    ]

    result = quick_vasp_sequential(
        structure=si,
        stages=stages,
        code_label=code_label,
        kpoints_spacing=0.06,
        potential_family='PBE',
        potential_mapping={'Si': 'Si'},
        options=options,
        name='tier3_ref_batch_si_encut',
    )
    pk = result['__workgraph_pk__']
    pks = {
        'batch_si_encut': {
            'pk': pk,
            'code_label': code_label,
            'description': 'Si diamond batch with 3 ENCUT values (200, 250, 300)',
            'stage_names': result.get('__stage_names__', []),
            'stage_types': result.get('__stage_types__', {}),
            'stage_namespaces': result.get('__stage_namespaces__', {}),
        }
    }
    print(f"  Submitted batch Si ENCUT scan: PK={pk}")
    return pks


def generate_aimd_references(code_label, options):
    """Submit AIMD reference calculation: Si short MD."""
    from teros.core.lego import quick_aimd

    si = load_si_structure()

    result = quick_aimd(
        structure=si,
        code_label=code_label,
        aimd_stages=[
            {
                'name': 'short_md',
                'tebeg': 300,
                'nsw': 5,
                'splits': 1,
                'potim': 2.0,
                'mdalgo': 2,
                'smass': 0.0,
            },
        ],
        incar={
            'encut': 200,
            'ediff': 1e-4,
            'prec': 'Normal',
            'lreal': 'Auto',
        },
        kpoints_spacing=0.5,
        potential_family='PBE',
        potential_mapping={'Si': 'Si'},
        options=options,
        name='tier3_ref_aimd_si',
    )
    pk = result['__workgraph_pk__']
    pks = {
        'aimd_si': {
            'pk': pk,
            'code_label': code_label,
            'description': 'Si diamond short AIMD (5 steps, T=300K)',
            'stage_names': result.get('__stage_names__', []),
            'stage_types': result.get('__stage_types__', {}),
            'stage_namespaces': result.get('__stage_namespaces__', {}),
        }
    }
    print(f"  Submitted AIMD Si: PK={pk}")
    return pks


def generate_sequential_references(code_label, options):
    """Submit sequential reference: Si relax -> SCF."""
    from teros.core.lego import quick_vasp_sequential

    si = load_si_structure()

    stages = [
        {
            'name': 'relax',
            'type': 'vasp',
            'incar': {
                'encut': 300,
                'ediff': 1e-5,
                'ibrion': 2,
                'nsw': 20,
                'isif': 3,
                'ismear': 0,
                'sigma': 0.05,
                'prec': 'Normal',
                'lwave': False,
                'lcharg': False,
                'lreal': 'Auto',
            },
            'restart': None,
        },
        {
            'name': 'scf',
            'type': 'vasp',
            'structure_from': 'relax',
            'incar': {
                'encut': 300,
                'ediff': 1e-5,
                'ibrion': -1,
                'nsw': 0,
                'ismear': 0,
                'sigma': 0.05,
                'prec': 'Normal',
                'lwave': False,
                'lcharg': False,
                'lreal': 'Auto',
            },
            'restart': None,
        },
    ]

    result = quick_vasp_sequential(
        structure=si,
        stages=stages,
        code_label=code_label,
        kpoints_spacing=0.06,
        potential_family='PBE',
        potential_mapping={'Si': 'Si'},
        options=options,
        name='tier3_ref_sequential_si',
    )
    pk = result['__workgraph_pk__']
    pks = {
        'relax_then_scf_si': {
            'pk': pk,
            'code_label': code_label,
            'description': 'Si diamond relax -> SCF sequential pipeline',
            'stage_names': result.get('__stage_names__', []),
            'stage_types': result.get('__stage_types__', {}),
            'stage_namespaces': result.get('__stage_namespaces__', {}),
        }
    }
    print(f"  Submitted sequential Si: PK={pk}")
    return pks


# =============================================================================
# Status checking
# =============================================================================

def check_status():
    """Print status of all reference calculations."""
    from teros.core.lego.utils import get_status

    data = load_existing_pks()
    all_finished = True

    for brick_type, scenarios in data.items():
        if brick_type.startswith('_'):
            continue
        for scenario_name, scenario in scenarios.items():
            pk = scenario.get('pk')
            if pk is None:
                print(f"  {brick_type}/{scenario_name}: NOT SUBMITTED")
                all_finished = False
                continue
            status = get_status(pk)
            finished = status == 'finished'
            if not finished:
                all_finished = False
            marker = '✓' if finished else '⏳'
            print(f"  {marker} {brick_type}/{scenario_name}: PK={pk} → {status}")

    return all_finished


def wait_for_all(poll_interval=15):
    """Wait for all submitted references to finish."""
    print("Waiting for all reference calculations to finish...")
    while True:
        all_done = check_status()
        if all_done:
            print("\nAll reference calculations finished!")
            return True
        print(f"\n  ... waiting {poll_interval}s ...")
        time.sleep(poll_interval)


# =============================================================================
# Main
# =============================================================================

GENERATORS = {
    'vasp': generate_vasp_references,
    'dos': generate_dos_references,
    'batch': generate_batch_references,
    'aimd': generate_aimd_references,
    'sequential': generate_sequential_references,
}


def main():
    parser = argparse.ArgumentParser(
        description='Generate tier3 reference calculations for lego tests.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument(
        '--code', '-c',
        help='VASP code label (e.g., VASP-6.5.1@localwork)',
    )
    parser.add_argument(
        '--brick', '-b',
        choices=list(GENERATORS.keys()),
        help='Generate references for a specific brick only',
    )
    parser.add_argument(
        '--status', '-s',
        action='store_true',
        help='Check status of existing reference calculations',
    )
    parser.add_argument(
        '--wait', '-w',
        action='store_true',
        help='Wait for all references to finish',
    )
    parser.add_argument(
        '--poll', '-p',
        type=float,
        default=15,
        help='Poll interval in seconds for --wait (default: 15)',
    )

    args = parser.parse_args()

    # Load AiiDA
    try:
        from aiida import load_profile
        load_profile()
    except Exception as e:
        print(f"ERROR: Cannot load AiiDA profile: {e}", file=sys.stderr)
        sys.exit(1)

    # Status check mode
    if args.status:
        print("Reference calculation status:")
        check_status()
        return

    # Wait mode
    if args.wait:
        wait_for_all(args.poll)
        return

    # Generation mode
    if not args.code:
        parser.error("--code is required when generating references")

    code_label = args.code
    options = get_light_options(code_label)

    data = load_existing_pks()

    if args.brick:
        bricks = [args.brick]
    else:
        bricks = list(GENERATORS.keys())

    print(f"Generating reference calculations with code: {code_label}")
    print(f"Bricks: {', '.join(bricks)}")
    print()

    for brick_name in bricks:
        print(f"[{brick_name}]")
        gen_func = GENERATORS[brick_name]
        pks = gen_func(code_label, options)

        # Merge into data (strip result_dict for JSON serialization)
        for scenario_name, scenario in pks.items():
            scenario.pop('result_dict', None)
            data[brick_name][scenario_name] = scenario

        save_pks(data)
        print()

    print("All submissions complete. Use --status to check progress.")
    print("Use --wait to block until all calculations finish.")


if __name__ == '__main__':
    main()
